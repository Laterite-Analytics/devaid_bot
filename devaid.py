# devaid.py  (Anvil Server Module, Full‑Python)
import datetime as _dt
import html
import os
import re
from typing import List

import requests
from bs4 import BeautifulSoup
from dotenv import load_dotenv

load_dotenv()

# ── Slack connection ────────────────────────────────────────────────────
SLACK_WEBHOOK_URL = os.getenv("SLACK_WEBHOOK_URL")


def slack_post_message(text: str):
    """Send a message to Slack using an incoming webhook."""
    if not SLACK_WEBHOOK_URL:
        print("[WARN] SLACK_WEBHOOK_URL not set, message skipped.")
        return
    payload = {"text": text}
    try:
        r = requests.post(SLACK_WEBHOOK_URL, json=payload, timeout=10)
        r.raise_for_status()
    except Exception as e:
        print(f"[ERROR sending Slack message]: {e}")


# ── DevAid connection ────────────────────────────────────────────────────
API_KEY = os.getenv("DEVAID_API_KEY")
BASE_URL = "https://www.developmentaid.org/api/external"
TIMEOUT = 30

headers = {
    "X-API-KEY": API_KEY,
}

# To obtain the country IDs, run: requests.get(f"{BASE_URL}/dictionaries/locations/global-regions", headers=headers).json()
countries = {
    "Kenya": 35,
    "Rwanda": 51,
    "Ethiopia": 28,
    "Tanzania": 62,
    "Uganda": 65,
    "Sierra Leone": 56,
    "Peru": 109,
}

sectors = {
    "Agriculture": 100,
    "Education": 5,
    "Energy": 6,
    "Environment & NRM": 7,
    "Gender": 9,
    "Health": 11,
    "Labour Market & Employment": 14,
    "Micro-finance": 17,
}


# ------------------  low‑level helpers  ----------------------------------


def _json_ok(r, *, debug=False):
    if debug:
        print("DEBUG‑HEADERS:", r.status_code, dict(r.headers))
        try:
            print("DEBUG‑BODY   :", r.text[:800])
        except Exception:
            pass
    r.raise_for_status()
    if "application/json" not in r.headers.get("Content-Type", ""):
        raise RuntimeError("Expected JSON, got " + r.headers.get("Content-Type", ""))
    return r.json()


def fetch_tender_details(tender_id):
    response = requests.get(
        f"{BASE_URL}/tenders/{tender_id}", headers=headers, timeout=TIMEOUT
    )
    tender = _json_ok(response)
    print(f"  ↳ Donor: {', '.join(d['name'] for d in tender['donors'])}")
    print(f"  ↳ URL: {tender['url']}")
    return tender


# ------------------  message formatting  ----------------------------------


def format_tenders_for_slack(tenders):
    if not tenders:
        return f"No new tenders were found this week ({_dt.date.today():%d %b %Y})."

    slack_message_text = (
        f"📢 *New Tenders Update — Week of {_dt.date.today():%d %b %Y}*\n"
    )
    slack_message_text += "──────────────────────────────\n"
    slack_message_text += f"*{len(tenders)} new tenders* were published this week:\n\n"

    for i, tender in enumerate(tenders, 1):
        title = tender.get("name", "Untitled Tender")
        tender_id = tender.get("id")
        status = tender.get("status", "unknown").capitalize()
        posted = tender.get("postedDate", "N/A")
        deadline = tender.get("deadline", "N/A")

        slack_message_text += (
            f"*{i}. {title}*\n"
            f"• 🆔 *ID:* {tender_id}\n"
            f"• 📅 *Posted on:* {posted}\n"
            f"• ⏰ *Deadline:* {deadline}\n"
            f"• 🚦 *Status:* {status}\n\n"
        )

    slack_message_text += "──────────────────────────────\n"
    slack_message_text += (
        "_This summary was automatically generated by the BDC tender fetcher bot._ 🤖"
    )

    return slack_message_text


def format_tender_description_for_slack(tender):
    """
    Format a tender detail into a professional Slack message
    for the BDC team, when responding to a request for more info.
    """
    title = tender.get("name", "Untitled Tender")
    url = tender.get("url", "")
    deadline = tender.get("deadline", "N/A")
    posted = tender.get("postedDate", "N/A")
    status = tender.get("status", "unknown").capitalize()

    organization = tender.get("organization", {}).get("name", "Unknown organization")
    donor = ", ".join([d.get("name", "") for d in tender.get("donors", [])]) or "N/A"
    country = (
            ", ".join([loc.get("name", "") for loc in tender.get("locations", [])])
            or "Unspecified"
    )
    sector = (
            ", ".join([s.get("name", "") for s in tender.get("sectors", [])])
            or "Unspecified"
    )
    tender_type = (
            ", ".join([t.get("name", "") for t in tender.get("types", [])]) or "N/A"
    )
    eligibility = tender.get("eligibility", {}).get("name", "N/A")

    # Clean up and simplify the description
    raw_description = tender.get("description", "")
    soup = BeautifulSoup(raw_description, "html.parser")
    text = soup.get_text()
    description = html.unescape(text)
    description = re.sub(r"\n{2,}", "\n", description).strip()

    amount = tender.get("amount", {})
    budget = amount.get("value")
    currency = amount.get("currency")
    budget_str = f"{budget:,} {currency}" if budget and currency else "Not specified"

    # Contact info
    contact_email = tender.get("email") or tender.get("contactEmail") or ""
    contacts = tender.get("contacts", [])
    contact_lines = []
    for c in contacts:
        name = c.get("name", "")
        mail = c.get("mainEmail", "")
        if name or mail:
            contact_lines.append(f"{name} ({mail})" if name else mail)
    contact_text = ", ".join(contact_lines) or contact_email or "N/A"

    slack_message = (
        f"*Tender Details — {title}*\n"
        f"──────────────────────────────\n"
        f"• 🏢 *Organization:* {organization}\n"
        f"• 🌍 *Country:* {country}\n"
        f"• 🎯 *Sector:* {sector}\n"
        f"• 💰 *Budget:* {budget_str}\n"
        f"• 🤝 *Donor:* {donor}\n"
        f"• 📅 *Posted on:* {posted}\n"
        f"• ⏰ *Deadline:* {deadline}\n"
        f"• 🚦 *Status:* {status}\n"
        f"──────────────────────────────\n"
        f"*Summary:*\n{description[:2000]}{'...' if len(description) > 2000 else ''}\n\n"
        f"📧 *Contact:* {contact_text}\n"
    )

    if url:
        slack_message += f"🔗 *More info:* <{url}|Open Tender Page>\n"

    slack_message += f"\n──────────────────────────────\n"
    slack_message += (
        f"_Provided by the BDC Tender Fetcher Bot — {_dt.date.today():%d %b %Y}_ 🤖"
    )

    return slack_message


# ── Background task ------------------------------------------------------


def fetch_new_tenders(days_back=7, page_size=50):
    today = _dt.date.today()
    week_ago = today - _dt.timedelta(days=days_back)

    body = {
        "sort": "posted_date.desc",
        "page": 1,
        "size": page_size,
        "filter": {
            "keyword": {"searchedText": "survey | research | evaluation | monitoring",
                        "searchedFields": ["title", "description", "documents"]},
            "locations": list(countries.values()),
            "sectors": list(sectors.values()),
            "postedFrom": str(week_ago),
            "postedTill": str(today),
            "statuses": [
                2,
                3,
                8,
                9,
                10,
            ],
            # :[{"id":8,"name":"country programming","stage":{"id":"early_intelligence","name":"Early intelligence"}},{"id":9,"name":"formulation","stage":{"id":"early_intelligence","name":"Early intelligence"}},{"id":10,"name":"approval","stage":{"id":"early_intelligence","name":"Early intelligence"}},{"id":2,"name":"forecast","stage":{"id":"procurement","name":"Procurement"}},{"id":3,"name":"open","stage":{"id":"procurement","name":"Procurement"}},{"id":4,"name":"closed","stage":{"id":"procurement","name":"Procurement"}},{"id":5,"name":"shortlisted","stage":{"id":"procurement","name":"Procurement"}},{"id":6,"name":"awarded","stage":{"id":"procurement","name":"Procurement"}},{"id":7,"name":"cancelled","stage":{"id":"procurement","name":"Procurement"}},{"id":11,"name":"completion and evaluation","stage":{"id":"implementation","name":"Implementation"}}]
            "tenderTypes": [4],  # consulting services
            "eligibilityAlias": "organisation",
            "budgetInEuroRange": {
                "min": 50000,
                "max": 20000000,
            },  # 50k to 20M EUR, 20M is the max allowed
            # "locationIsStrict": false,
            # "sectorsIsStrict": false,
            # "typesIsStrict": false,
        },
    }
    try:
        # Fetch tenders
        response = requests.post(
            f"{BASE_URL}/tenders/search", headers=headers, json=body
        )
        tenders = _json_ok(response).get("items", [])
        print(f"Fetched {len(tenders)} new tenders from DevAid.")
        # Build Slack message text
        slack_message_text = format_tenders_for_slack(tenders)
    except requests.HTTPError as e:
        tenders = []
        slack_message_text = (
            f"❌ Error fetching tenders. Please report to the analytics team. ({e})"
        )

    print(slack_message_text)

    return [tenders[i]["id"] for i in range(len(tenders))]


def fetch_multiple_tenders_details(tender_ids: List[str]):
    tender_details = {}
    for tender_id in tender_ids:
        try:
            info = fetch_tender_details(tender_id)
            tender_details[tender_id] = info
            slack_message_text = format_tender_description_for_slack(info)
            slack_post_message(slack_message_text[:4000])
        except Exception as e:
            print(f"  [ERROR fetching details for {tender_id}: {e}]")
            continue
    return tender_details


if __name__ == "__main__":
    new_tender_ids = fetch_new_tenders()
    fetch_multiple_tenders_details(new_tender_ids)
